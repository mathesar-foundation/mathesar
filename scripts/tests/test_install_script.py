import os
import shutil
import subprocess
import tarfile
from pathlib import Path
import pytest


# Basic helpers

def _write_executable(path: Path, content: str) -> None:
    path.write_text(content, encoding="utf-8")
    path.chmod(0o755)


def _ensure_dir(path: Path) -> None:
    """`mkdir -p` equivalent."""
    path.mkdir(parents=True, exist_ok=True)


# uv helpers

_UV_STUB_TEMPLATE = """#!/usr/bin/env bash
# dummy uv generated by tests
if [[ $1 == self && $2 == version ]]; then echo "{version}"
elif [[ $1 == python && $2 == find ]]; then exit {python_find_exit}
elif [[ $1 == python && $2 == install ]]; then echo install; exit 0
elif [[ $1 == venv ]]; then
  mkdir -p "$2/bin"
  echo '#!/usr/bin/env bash' > "$2/bin/python"
  chmod +x "$2/bin/python"
  echo true > "$2/bin/activate"
  exit 0
elif [[ $1 == add ]]; then exit 0
fi
"""


def write_uv_stub(
    target: Path,
    *,
    version: str = "0.6.13",
    python_find_exit: int = 0,
) -> None:
    _write_executable(
        target,
        _UV_STUB_TEMPLATE.format(
            version=version,
            python_find_exit=python_find_exit,
        ),
    )


def write_uv_installer(installer_path: Path, uv_target: Path, *, good_version: str = "0.6.13") -> None:
    """
    Stub `uv-installer.sh` that always replaces *uv_target* with a fresh,
    *working* stub printing `good_version`.
    """
    stub_body = _UV_STUB_TEMPLATE.format(version=good_version, python_find_exit=0)
    _write_executable(
        installer_path,
        f"""#!/usr/bin/env bash
set -e
cat > "{uv_target}" <<'EOF'
{stub_body}
EOF
chmod +x "{uv_target}"
echo "Dummy uv installed"
""",
    )


# Packaging helper

def _create_dummy_tar_archive(dest: Path) -> None:
    pkg_dir = dest.parent / "dummy_pkg"
    _ensure_dir(pkg_dir)
    (pkg_dir / "dummy.txt").write_text("dummy")
    for sub in ["config", "db", "mathesar"]:
        _ensure_dir(pkg_dir / sub)
    with tarfile.open(dest, "w:gz") as tar:
        tar.add(pkg_dir, arcname="")
    shutil.rmtree(pkg_dir)


# Fixtures

@pytest.fixture(scope="session")
def script_path() -> Path:
    p = Path(__file__).resolve().parent.parent / "install.sh"
    if not p.exists():
        pytest.skip("install.sh not found")
    return p


@pytest.fixture
def dummy_package_archive(tmp_path: Path) -> Path:
    archive = tmp_path / "mathesar-0.2.3.tar.gz"
    _create_dummy_tar_archive(archive)
    return archive


@pytest.fixture
def dummy_bin(tmp_path: Path, dummy_package_archive: Path) -> Path:
    """
    Fake curl/wget that simply copy the local tarball instead of hitting the net.
    """
    bin_dir = tmp_path / "dummy_bin"
    _ensure_dir(bin_dir)

    for tool, flag in [("curl", "-o"), ("wget", "-O")]:
        _write_executable(
            bin_dir / tool,
            f"""#!/bin/bash
while (( $# )); do
  if [[ $1 == "{flag}" ]]; then shift; dest=$1; else url=$1; fi; shift
done
cp "{dummy_package_archive}" "${{dest:-${{url#file://}}}}"
""",
        )
    return bin_dir


@pytest.fixture
def default_env(tmp_path: Path, dummy_bin: Path) -> dict:
    fake_home = tmp_path / "home"
    _ensure_dir(fake_home)
    env = os.environ.copy()
    env.update(
        {
            "PATH": str(dummy_bin) + os.pathsep + env.get("PATH", ""),
            "HOME": str(fake_home),
            "SHELL": "/bin/sh",
            "PS1": "",
        }
    )
    return env


# Dummy environment setup

def setup_dummy_mathesar_env(install_dir: Path, archive: Path) -> None:
    """
    Populate *install_dir* with everything `install.sh` needs, entirely offline.
    Idempotent: safe to call even if parts already exist.
    """
    _ensure_dir(install_dir)

    uv_dir = install_dir / "uv"
    _ensure_dir(uv_dir)
    write_uv_stub(uv_dir / "uv")
    write_uv_installer(install_dir / "uv-installer.sh", uv_dir / "uv")

    _ensure_dir(install_dir / "setup")
    _write_executable(
        install_dir / "setup" / "process_env.py",
        "#!/usr/bin/env python3\nimport sys; sys.stdout.write(sys.stdin.read())",
    )

    _ensure_dir(install_dir / "mathesar")
    _write_executable(
        install_dir / "mathesar" / "install.py",
        "#!/usr/bin/env python3\nprint('Dummy Django migrations run')",
    )

    (install_dir / "requirements.txt").write_text("dummy\n")

    bin_dir = install_dir / "bin"
    _ensure_dir(bin_dir)
    _write_executable(bin_dir / "mathesar", "#!/bin/bash\necho 'Mathesar run'")

    pkg_dir = install_dir / "packages"
    _ensure_dir(pkg_dir)
    shutil.copy(archive, pkg_dir / archive.name)


def run_install(script: Path, install_dir: Path, *, args=None, env=None):
    cmd = ["bash", str(script), str(install_dir)] + (args or [])
    return subprocess.run(cmd, text=True, capture_output=True, env=env)


def assert_steps_present(stdout: str, steps: list[str]) -> None:
    lines = stdout.splitlines()
    for step in steps:
        assert any(step in line for line in lines), f"'{step}' missing"


# Happy path

_HAPPY = [
    # xdg, rcfiles, expect_symlink, expect_path_src, id
    (False, False, False, False, "core"),
    (True, True, True, False, "with_symlink"),
    (False, True, False, True, "without_symlink"),
]


@pytest.mark.parametrize(
    "xdg, rcfiles, want_symlink, want_path_src, _id",
    _HAPPY,
    ids=[p[4] for p in _HAPPY],
)
def test_successful_installation(
    script_path, tmp_path, dummy_package_archive, default_env,
    xdg, rcfiles, want_symlink, want_path_src, _id,
):
    install_dir = tmp_path / "mathesar_install"
    setup_dummy_mathesar_env(install_dir, dummy_package_archive)

    # optional rcfiles
    home = Path(default_env["HOME"])
    if rcfiles:
        for rc in [".bashrc", ".bash_profile", ".profile", ".zshrc", ".zshenv"]:
            (home / rc).write_text("export X=1\n")

    # optional XDG bin home
    if xdg:
        link_dir = tmp_path / "xdg_bin"
        _ensure_dir(link_dir)
        default_env["XDG_BIN_HOME"] = str(link_dir)
        default_env["PATH"] = str(link_dir) + os.pathsep + default_env["PATH"]
    else:
        link_dir = tmp_path / "unused_bin"

    res = run_install(
        script_path,
        install_dir,
        args=[
            "--connection-string", "postgres://u:p@h:5432/db",
            "--no-prompt",
            "--test-package-location", dummy_package_archive.resolve().as_uri(),
        ],
        env=default_env,
    )
    assert res.returncode == 0

    assert_steps_present(
        res.stdout,
        [
            "Creating required directories",
            "Extracting package",
            "Installing Python packages",
            "Running Django migrations & collecting static files",
            "Mathesar's installed successfully",
        ],
    )

    if want_symlink:
        link = Path(default_env["XDG_BIN_HOME"]) / "mathesar"
        assert link.exists() and os.readlink(link) == str(install_dir / "bin/mathesar")
    else:
        assert not (link_dir / "mathesar").exists()

    if want_path_src:
        src_script = install_dir / "bin" / "mathesar_path_source"
        assert src_script.exists()
        line = f'source "{src_script}"'
        for rc in ["bashrc", "bash_profile", "profile", "zshrc", "zshenv"]:
            assert line in (home / f".{rc}").read_text()


# Other branches

def test_skip_download_when_archive_exists(script_path, tmp_path, dummy_package_archive, default_env):
    install_dir = tmp_path / "mathesar_install"
    _ensure_dir(install_dir / "packages")
    # pre‑seed package already downloaded
    shutil.copy(dummy_package_archive, install_dir / "packages" / dummy_package_archive.name)

    setup_dummy_mathesar_env(install_dir, dummy_package_archive)

    res = run_install(
        script_path,
        install_dir,
        args=[
            "--connection-string", "postgres://u:p@h:5432/db",
            "--no-prompt",
            "--test-package-location", dummy_package_archive.resolve().as_uri(),
        ],
        env=default_env,
    )
    assert res.returncode == 0
    assert "Package archive already exists." in res.stdout


def test_uv_version_mismatch_reinstall(script_path, tmp_path, dummy_package_archive, default_env):
    install_dir = tmp_path / "mathesar_install"
    setup_dummy_mathesar_env(install_dir, dummy_package_archive)

    # break uv
    _write_executable(install_dir / "uv" / "uv", "#!/bin/bash\necho 0.0.1")

    res = run_install(
        script_path,
        install_dir,
        args=[
            "--connection-string", "postgres://u:p@h:5432/db",
            "--no-prompt",
            "--test-package-location", dummy_package_archive.resolve().as_uri(),
        ],
        env=default_env,
    )
    assert res.returncode == 0
    assert "uv version (0.0.1) does not match required version" in res.stdout
    assert "Re-installing uv..." in res.stdout
    assert "Mathesar's installed successfully" in res.stdout


def test_force_download_python(script_path, tmp_path, dummy_package_archive, default_env):
    install_dir = tmp_path / "mathesar_install"
    setup_dummy_mathesar_env(install_dir, dummy_package_archive)

    # Replace uv with a stub that fails 'python find' (exit‑code 1) but is
    # otherwise functional.
    write_uv_stub(
        install_dir / "uv" / "uv",
        python_find_exit=1,
    )

    res = run_install(
        script_path,
        install_dir,
        args=[
            "--force-download-python",
            "--connection-string", "postgres://u:p@h:5432/db",
            "--no-prompt",
            "--test-package-location", dummy_package_archive.resolve().as_uri(),
        ],
        env=default_env,
    )
    assert res.returncode == 0
    assert "Downloading Python locally" in res.stdout
    assert (install_dir / "mathesar-venv" / "bin" / "activate").exists()

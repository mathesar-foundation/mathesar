{"version":3,"file":"placeholder.min.js","mappings":"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","sources":["webpack:///./src/debug.ts","webpack:///./src/validator.ts","webpack:///./src/state_manager.ts","webpack:///./src/replacer.ts","webpack:///./src/dependency_graph.ts","webpack:///./src/parse_settings.ts","webpack:///./src/auto_tables.ts","webpack:///./src/inputs.ts","webpack:///./src/main.ts","webpack:///./src/api.ts","webpack:///./src/index.ts"],"sourcesContent":["const timestamp = () => `${new Date().toISOString().slice(11, 23)} (TS)`;\nlet is_reload_enabled = true;\nfunction internal_log(...args) {\n    console.log.apply(console, [`${timestamp()} |`, ...arguments]);\n}\nfunction internal_info(...args) {\n    console.info.apply(console, [`${timestamp()} |`, ...arguments]);\n}\nfunction internal_debug(...args) {\n    console.debug.apply(console, [`${timestamp()} |`, ...arguments]);\n}\nfunction noop(...args) {\n}\nexport const reload_page = () => {\n    if (is_reload_enabled) {\n        window.location.reload();\n    }\n    else {\n        internal_info(\"Page reload was triggered and blocked due to PlaceholderPlugin.debug_disable_reload\");\n    }\n};\nconst noop_logger = {\n    \"log\": noop,\n    \"info\": noop,\n    \"debug\": noop,\n};\nexport const init_logging = (enable_debug) => {\n    if (enable_debug) {\n        // Write debugging messages to console\n        logger = {\n            \"log\": internal_log,\n            \"info\": internal_info,\n            \"debug\": internal_debug,\n        };\n    }\n    else {\n        // If debugging is disabled, make the functions do nothing\n        logger = noop_logger;\n        return;\n    }\n};\nexport let logger = noop_logger;\n// You can call this manually from the browser's console to temporarily disable reloads and debug the application\nexport const debug_disable_reload = () => {\n    internal_info(\"Page reload was disabled for debugging purposes\");\n    is_reload_enabled = false;\n};\n","import { logger } from \"./debug\";\nimport { get_array_field, get_boolean_field, get_string_field } from \"./parse_settings\";\nexport var ValidatorSeverity;\n(function (ValidatorSeverity) {\n    ValidatorSeverity[\"Warning\"] = \"WARNING\";\n    ValidatorSeverity[\"Error\"] = \"ERROR\";\n})(ValidatorSeverity || (ValidatorSeverity = {}));\nexport var PlaceholderValidatity;\n(function (PlaceholderValidatity) {\n    PlaceholderValidatity[\"Good\"] = \"GOOD\";\n    PlaceholderValidatity[\"Warning\"] = \"WARNING\";\n    PlaceholderValidatity[\"Error\"] = \"ERROR\";\n    PlaceholderValidatity[\"NoValidator\"] = \"NO_VALIDATOR\";\n})(PlaceholderValidatity || (PlaceholderValidatity = {}));\nexport const parse_validator = (data) => {\n    const rules = get_array_field(\"rules\", \"object\", data);\n    if (rules.length == 0) {\n        throw new Error(`Rules should not be an empty array.\\nProblematic object: ${JSON.stringify(data)}`);\n    }\n    const id = get_string_field(\"id\", data);\n    return {\n        \"display_name\": get_string_field(\"display_name\", data),\n        \"id\": id,\n        \"rules\": rules.map(x => parse_rule(x, id)),\n    };\n};\nconst is_valid_value = (validator, value) => {\n    for (const rule of validator.rules) {\n        if (rule.is_match_function(value) != rule.should_match) {\n            // this rule rejects the value\n            if (rule.severity == ValidatorSeverity.Error) {\n                // immediately return once we found a hard failure\n                return false;\n            }\n        }\n    }\n    // no real errors -> is valid\n    return true;\n};\nexport const is_valid_value_for_placeholder = (placeholder, value) => {\n    // @TODO decide: validate normal value or expanded value? Needs to be checked for every function call\n    if (placeholder.validators.length > 0) {\n        for (const validator of placeholder.validators) {\n            if (is_valid_value(validator, value)) {\n                // a single validator accepting it is enough\n                return true;\n            }\n        }\n        // no validator accepted it -> bad\n        return false;\n    }\n    else {\n        return true;\n    }\n};\nconst validate_value = (validator, value) => {\n    const warnings = [];\n    const errors = [];\n    for (const rule of validator.rules) {\n        if (rule.is_match_function(value) != rule.should_match) {\n            // this rule rejects the value\n            if (rule.severity == ValidatorSeverity.Error) {\n                errors.push(`[${validator.display_name}] Error: ${rule.error_message}`);\n            }\n            else if (rule.severity == ValidatorSeverity.Warning) {\n                warnings.push(`[${validator.display_name}] Warning: ${rule.error_message}`);\n            }\n            else {\n                console.warn(`Unknown rule severity ${rule.severity}`);\n            }\n        }\n    }\n    return {\n        \"errors\": errors,\n        \"warnings\": warnings,\n    };\n};\nconst validate_placeholder_value = (placeholder, value) => {\n    const result_list = [];\n    let has_no_error = false; // whether at least one placeholder has no errors\n    if (placeholder.validators.length > 0) {\n        for (const validator of placeholder.validators) {\n            const result = validate_value(validator, value);\n            result_list.push(result);\n            if (result.errors.length == 0) {\n                has_no_error = true;\n                if (result.warnings.length == 0) {\n                    return placeholder_is_good(placeholder);\n                }\n            }\n        }\n        if (has_no_error) {\n            return placeholder_is_warning(result_list);\n        }\n        else {\n            return placeholder_is_error(result_list);\n        }\n    }\n    else {\n        return {\n            \"rating\": PlaceholderValidatity.NoValidator,\n            \"message\": \"No validators are specified for this placeholder\",\n        };\n    }\n};\nconst placeholder_is_error = (result_list) => {\n    // If all of them have errors, we will ignore the warnings to keep it shorter\n    const errors = [];\n    for (const result of result_list) {\n        errors.push(...result.errors);\n    }\n    return {\n        \"rating\": PlaceholderValidatity.Error,\n        \"message\": errors.join(\"\\n\"),\n    };\n};\nconst placeholder_is_warning = (result_list) => {\n    // If some return warnings and some return errors, we will only show the ones with warnings.\n    const lines = [];\n    for (const result of result_list) {\n        if (result.errors.length == 0) {\n            lines.push(...result.warnings);\n        }\n    }\n    return {\n        \"rating\": PlaceholderValidatity.Warning,\n        \"message\": lines.join(\"\\n\"),\n    };\n};\nconst placeholder_is_good = (placeholder) => {\n    // If one of them has neither warnings or errors, we return Good status immediately\n    let message;\n    if (placeholder.validators.length == 1) {\n        message = `Expecting: ${placeholder.validators[0].display_name}`;\n    }\n    else {\n        message = \"Expecting one of the following: \";\n        for (const v of placeholder.validators) {\n            message += `\\n - ${v.display_name}`;\n        }\n    }\n    return {\n        \"rating\": PlaceholderValidatity.Good,\n        \"message\": message,\n    };\n};\nconst parse_rule = (data, validator_id) => {\n    const severity_str = get_string_field(\"severity\", data);\n    let severity;\n    if (severity_str == \"warning\" || severity_str == \"warn\") {\n        severity = ValidatorSeverity.Warning;\n    }\n    else if (severity_str == \"error\") {\n        severity = ValidatorSeverity.Error;\n    }\n    else {\n        throw new Error(`Unknown severity '${severity_str}'`);\n    }\n    let is_match_function;\n    if (data.regex) {\n        const regex = get_string_field(\"regex\", data);\n        const compiled_regex = new RegExp(regex);\n        is_match_function = (value) => compiled_regex.test(value);\n    }\n    else {\n        const match_function_body = get_string_field(\"match_function\", data);\n        // we need to use Function instead of eval(), since minification will rename the argument\n        // this may also be more performant, since the code is only compiled once\n        const match_function = new Function(\"value\", match_function_body);\n        is_match_function = (value) => {\n            try {\n                const result = match_function(value);\n                if (typeof (result) != \"boolean\") {\n                    throw new Error(`Custom match_function '${match_function_body}' of validator ${validator_id} should return a boolean, but it returned a ${typeof (result)}: ${result}`);\n                }\n                else {\n                    return result;\n                }\n            }\n            catch (error) {\n                throw new Error(`Failed to evaluate match_function '${match_function_body}' of validator ${validator_id}: ${error}`);\n            }\n        };\n    }\n    return {\n        \"severity\": severity,\n        \"should_match\": get_boolean_field(\"should_match\", data),\n        \"error_message\": get_string_field(\"error_message\", data),\n        \"is_match_function\": is_match_function,\n    };\n};\nconst update_tooltip = (input_field, validation_result) => {\n    // Set highlighting\n    input_field.classList.remove(\"validation-error\", \"validation-warn\", \"validation-ok\", \"validation-none\");\n    if (validation_result.rating == PlaceholderValidatity.Good) {\n        input_field.classList.add(`validation-ok`);\n    }\n    else if (validation_result.rating == PlaceholderValidatity.Warning) {\n        input_field.classList.add(`validation-warn`);\n    }\n    else if (validation_result.rating == PlaceholderValidatity.Error) {\n        input_field.classList.add(`validation-error`);\n    }\n    else if (validation_result.rating == PlaceholderValidatity.NoValidator) {\n        input_field.classList.add(`validation-none`);\n    }\n    else {\n        console.warn(`Unknown placeholder validity: ${validation_result.rating}`);\n    }\n    // Set tooltip\n    input_field.title = validation_result.message;\n};\n// Returns \"false\" if the value has an error, so for example page reloading should be cancelled.\nexport const validate_textbox_input_field = (placeholder, input_field) => {\n    const result = validate_placeholder_value(placeholder, input_field.value);\n    update_tooltip(input_field, result);\n    logger.debug(\"Validation: name =\", placeholder.name, \", value =\", input_field.value, \", results =\", result.rating);\n    const can_accept_value = result.rating != PlaceholderValidatity.Error;\n    return can_accept_value;\n};\n","import { logger, reload_page } from \"./debug\";\nimport { is_valid_value_for_placeholder } from \"./validator\";\n// These functions are here to make it easier to change the storage backend (for example locasstorage -> cookies)\n// and to make it possible to potentially have better debugging\nconst STORAGE_PREFIX = \"PLACEHOLDER_\"; // @TODO make it configurable by settings?\nconst store_value = (name, value) => {\n    localStorage.setItem(STORAGE_PREFIX + name, value);\n};\nconst load_value = (name) => {\n    return localStorage.getItem(STORAGE_PREFIX + name);\n};\n// I changed the storage model: the real value is stored in the placeholder object instead of in localstorage -> easier and safer to access\n// We pass the whole placeholder instead of just a name, so that you can not accidentally call the wrong function or use an invalid placeholder name\n// We use different values for different types (checkbox -> NAME_IS_CHECKED, textbox -> NAME_TEXT, ...) so that if a user changes the type of a placeholder it should not cause problems\nexport const store_checkbox_state = (placeholder, new_is_checked) => {\n    // Update the placeholder's value\n    placeholder.current_is_checked = new_is_checked;\n    placeholder.current_value = new_is_checked ? placeholder.value_checked : placeholder.value_unchecked;\n    // Permanently store the new state\n    store_value(`${placeholder.name}_IS_CHECKED`, new_is_checked ? \"1\" : \"0\");\n};\nexport const load_checkbox_state = (placeholder) => {\n    const stored_state = load_value(`${placeholder.name}_IS_CHECKED`);\n    if (stored_state == null) {\n        // No stored state -> use default value\n        placeholder.current_is_checked = placeholder.checked_by_default;\n    }\n    else {\n        if (stored_state == \"0\" || stored_state == \"1\") {\n            // Load the stored state\n            placeholder.current_is_checked = stored_state == \"1\";\n        }\n        else {\n            // Unexpected state, warn user and fall back to default\n            console.warn(`Unexpected state for checkbox. Should be '0' or '1', but was '${stored_state}'`);\n            placeholder.current_is_checked = placeholder.checked_by_default;\n        }\n    }\n    // Now we update the actual value based on the state\n    placeholder.current_value = placeholder.current_is_checked ? placeholder.value_checked : placeholder.value_unchecked;\n};\nexport const clear_state = () => {\n    // The easiest way would be to clear the whole storage, but that might break other plugins / scripts.\n    // So we only delete all items that start with our prefix\n    console.warn(`Clearing all localStorage items starting with '${STORAGE_PREFIX}'`);\n    let i = 0;\n    while (i < localStorage.length) {\n        const key = localStorage.key(i);\n        if (key === null || key === void 0 ? void 0 : key.startsWith(STORAGE_PREFIX)) {\n            // Delete the item\n            localStorage.removeItem(key);\n        }\n        else {\n            // Not ours, so we skip it\n            i++;\n        }\n    }\n    reload_page();\n};\nconst is_valid_index = (placeholder, index) => {\n    try {\n        const item = placeholder.options[index];\n        return item != undefined && item != null;\n    }\n    catch (error) {\n        return false;\n    }\n};\nexport const store_dropdown_state = (placeholder, new_index) => {\n    // Perform sanity checks on the index\n    if (is_valid_index(placeholder, new_index)) {\n        store_value(`${placeholder.name}_INDEX`, `${new_index}`);\n        placeholder.current_value = placeholder.options[new_index].value;\n        placeholder.current_index = new_index;\n    }\n    else {\n        throw new Error(`Index must a whole number N, where 0 <= N < ${placeholder.options.length}. But it is ${new_index}`);\n    }\n};\nexport const load_dropdown_state = (placeholder) => {\n    const stored_state = load_value(`${placeholder.name}_INDEX`);\n    if (stored_state == null) {\n        // No stored state -> use default value\n        placeholder.current_index = placeholder.default_index;\n    }\n    else {\n        const stored_index = Number(stored_state);\n        if (is_valid_index(placeholder, stored_index)) {\n            // Load the stored state\n            placeholder.current_index = stored_index;\n        }\n        else {\n            // Unexpected state, warn user and fall back to default\n            console.warn(`Unexpected state for dropdown. Should be a whole number N, where 0 <= N < ${placeholder.options.length}. But it is ${stored_state}`);\n            placeholder.current_index = placeholder.default_index;\n        }\n    }\n    // Now we update the actual value based on the state\n    placeholder.current_value = placeholder.options[placeholder.current_index].value;\n};\nexport const store_textbox_state = (placeholder, new_value) => {\n    const is_validation_ok = is_valid_value_for_placeholder(placeholder, new_value);\n    logger.info(`Set textbox ${placeholder.name} to '${new_value}'. Validation ok? ${is_validation_ok}`);\n    if (is_validation_ok) {\n        store_value(`${placeholder.name}_TEXT`, new_value);\n    }\n    else {\n        throw new Error(`Validation error: Value '${new_value}' is not valid for placeholder ${placeholder.name}`);\n    }\n};\nexport const load_textbox_state = (placeholder) => {\n    const stored_state = load_value(`${placeholder.name}_TEXT`);\n    if (stored_state != null) {\n        if (is_valid_value_for_placeholder(placeholder, stored_state)) {\n            placeholder.current_value = stored_state;\n            return; // Do not use the default value / function\n        }\n        else {\n            console.warn(`Stored value for placeholder ${placeholder.name} is invalid: '${stored_state}'. Will revert to default.`);\n            // Should we remove the value? Idk\n        }\n    }\n    // Use a default value\n    if (placeholder.default_value != undefined) {\n        placeholder.current_value = placeholder.default_value;\n        if (!is_valid_value_for_placeholder(placeholder, placeholder.default_value)) {\n            console.warn(`Default value for placeholder '${placeholder.name}' is invalid: '${placeholder.default_value}'`);\n        }\n    }\n    else if (placeholder.default_function) {\n        try {\n            const result = placeholder.default_function();\n            placeholder.current_value = result;\n            try {\n                // store the function result, since it may be different with each invocation (such as a randomly generated password)\n                store_textbox_state(placeholder, result);\n            }\n            catch (error) {\n                console.warn(`Default function for placeholder '${placeholder.name}' returned invalid value: '${result}'`);\n            }\n        }\n        catch (error) {\n            // This will be called if the placeholder's custom function fails\n            console.error(`Error while loading default textbox state for placeholder ${placeholder.name}:`, error);\n            placeholder.current_value = \"DEFAULT_FUNCTION_ERROR\";\n        }\n    }\n    else {\n        throw new Error(`Either 'default_value' or 'default_function' needs to be set for placeholder ${placeholder.name}`);\n    }\n};\n","import { logger } from \"./debug\";\n// Replace a specific placeholder and return the estimated number of occurences (underestimated, may actually be higher)\nconst static_replace = (root_element, search_regex, replacement_value) => {\n    const walker = document.createTreeWalker(root_element, NodeFilter.SHOW_TEXT);\n    let node;\n    let count = 0;\n    if (!search_regex.global) {\n        console.warn(`You should set the global flag for the regex. Context: replacing '${search_regex.source}' with '${replacement_value}'`);\n    }\n    while (node = walker.nextNode()) {\n        if (node.nodeValue) {\n            const replaced_str = node.nodeValue.replace(search_regex, replacement_value);\n            if (node.nodeValue != replaced_str) {\n                node.nodeValue = replaced_str;\n                count++; // Of course, it might have been replaced multiple times by replaceAll. But this is just for debugging\n                // and performing an accurate count would impact the performace.\n            }\n        }\n    }\n    return count;\n};\nconst escapeHTML = (text) => {\n    const element = document.createElement(\"div\");\n    element.appendChild(document.createTextNode(text));\n    return element.innerHTML;\n};\nconst inner_html_replace = (root_element, search_regex, replacement_value) => {\n    // User supplied input, HTML escape it before we inject it in the page\n    replacement_value = escapeHTML(replacement_value);\n    if (!search_regex.global) {\n        console.warn(`You should set the global flag for the regex. Context: replacing '${search_regex.source}' with '${replacement_value}'`);\n    }\n    const new_value = root_element.innerHTML.replace(search_regex, replacement_value);\n    if (new_value != root_element.innerHTML) {\n        root_element.innerHTML = new_value;\n        return 1;\n    }\n    else {\n        return 0;\n    }\n};\nexport const create_dynamic_placeholder_element = (placeholder) => {\n    const span = document.createElement(\"span\");\n    span.classList.add(\"placeholder-value\");\n    span.dataset.placeholder = placeholder.name;\n    span.textContent = placeholder.expanded_value;\n    return span;\n};\nconst dynamic_replace = (root_element, search_regex, placeholder) => {\n    var _a;\n    const walker = document.createTreeWalker(root_element, NodeFilter.SHOW_TEXT);\n    let node;\n    if (!search_regex.global) {\n        console.warn(`You should set the global flag for the regex. Context: replacing '${search_regex.source}' with '${placeholder.current_value}'`);\n    }\n    const nodes_to_modify = [];\n    while (node = walker.nextNode()) {\n        if (node.nodeValue) {\n            if (node.nodeValue.match(search_regex)) {\n                // Do not modify in-place while iterating over the DOM\n                nodes_to_modify.push(node);\n            }\n        }\n    }\n    // Do not put in the value yet, otherwise it may be replaced by other placeholders\n    const replacement_value = `<span class=\"placeholder-value\" data-placeholder=\"${escapeHTML(placeholder.name)}\">TEMPORARY PLACEHOLDER</span>`;\n    for (const node of nodes_to_modify) {\n        if (node.nodeValue) {\n            const replaced_str = escapeHTML(node.nodeValue).replace(search_regex, replacement_value);\n            const new_node = document.createElement(\"span\");\n            new_node.innerHTML = replaced_str;\n            (_a = node.parentElement) === null || _a === void 0 ? void 0 : _a.replaceChild(new_node, node);\n        }\n    }\n    return nodes_to_modify.length;\n};\nconst do_dynamic_replace = (root_element, placeholder, config) => {\n    const count = dynamic_replace(root_element, placeholder.regex_dynamic, placeholder);\n    if (count > 0) {\n        logger.debug(`Replaced ${placeholder.name} via dynamic method at least ${count} time(s)`);\n        placeholder.count_on_page += count;\n    }\n};\nconst do_normal_replace = (root_element, placeholder, config) => {\n    const count = dynamic_replace(root_element, placeholder.regex_normal, placeholder);\n    if (count > 0) {\n        logger.debug(`Replaced ${placeholder.name} via normal (dynamic) method at least ${count} time(s)`);\n        placeholder.count_on_page += count;\n    }\n};\nconst do_static_replace = (root_element, placeholder, config) => {\n    const count = static_replace(root_element, placeholder.regex_static, placeholder.expanded_value);\n    if (count > 0) {\n        logger.debug(`Replaced ${placeholder.name} via static method at least ${count} time(s)`);\n        placeholder.count_on_page += count;\n        placeholder.reload_page_on_change = true;\n    }\n};\nconst do_html_replace = (root_element, placeholder, config) => {\n    const count = inner_html_replace(root_element, placeholder.regex_html, placeholder.expanded_value);\n    if (count > 0) {\n        logger.debug(`Replaced ${placeholder.name} via innerHTML method at least ${count} time(s)`);\n        placeholder.count_on_page += count;\n        placeholder.reload_page_on_change = true;\n    }\n};\n// Replace all placeholders in the given order and return which placeholders actually were actually found in the page\nexport const replace_placeholders_in_subtree = (root_element, config) => {\n    for (const placeholder of config.placeholders.values()) {\n        do_dynamic_replace(root_element, placeholder, config);\n        do_normal_replace(root_element, placeholder, config);\n        do_static_replace(root_element, placeholder, config);\n        if (placeholder.allow_inner_html) {\n            do_html_replace(root_element, placeholder, config);\n        }\n    }\n    find_dynamic_placeholder_wrappers(config);\n    replace_dynamic_placeholder_values([...config.placeholders.values()]);\n};\nexport const replace_placeholder_in_string = (text, placeholder) => {\n    // This funtion will perform replacements, but will ignore the replacement type (all will be simple/direct replace)\n    return text.replace(placeholder.regex_dynamic, placeholder.expanded_value)\n        .replace(placeholder.regex_html, placeholder.expanded_value)\n        .replace(placeholder.regex_normal, placeholder.expanded_value)\n        .replace(placeholder.regex_static, placeholder.expanded_value);\n};\nexport const replace_dynamic_placeholder_values = (placeholder_list) => {\n    for (const placeholder of placeholder_list) {\n        for (const element of placeholder.output_elements) {\n            // Delete current contents\n            element.innerHTML = \"\";\n            // Add the value back as safely escaped text\n            const text = document.createTextNode(placeholder.expanded_value);\n            element.appendChild(text);\n        }\n    }\n};\nconst find_dynamic_placeholder_wrappers = (config) => {\n    const output_list = document.querySelectorAll(\".placeholder-value[data-placeholder]\");\n    for (const element of output_list) {\n        const placeholder_name = element.getAttribute(\"data-placeholder\");\n        if (placeholder_name) {\n            const placeholder = config.placeholders.get(placeholder_name);\n            if (placeholder) {\n                placeholder.output_elements.push(element);\n            }\n            else {\n                console.warn(`No placeholder named '${placeholder_name}', that is referenced by element:`, element);\n            }\n        }\n        else {\n            console.warn(`Element has empty/no attribute 'data-placeholder':`, element);\n        }\n    }\n};\n","import { logger } from \"./debug\";\nimport { replace_placeholder_in_string } from \"./replacer\";\nimport { clear_state } from \"./state_manager\";\n// Should be a directed acyclical graph\nexport class DependencyGraph {\n    constructor(placeholders) {\n        this.nodes = new Map();\n        for (const placeholder of placeholders.values()) {\n            this.nodes.set(placeholder.name, new GraphNode(placeholder));\n        }\n        // Needs to be in different loops to ensure that all nodes have been created first\n        for (const placeholder of placeholders.values()) {\n            try {\n                this.on_placeholder_value_change(placeholder);\n            }\n            catch (e) {\n                console.error(\"Error while building dependency graph\", e);\n                console.warn(\"Placeholder values may be inconsistent. Clearing your localStorage should fix this problem.\");\n                if (confirm(\"We detected a problem with your placeholder values. Resetting them to the defaults should fix this. Should we reset your placeholders?\")) {\n                    clear_state();\n                }\n            }\n        }\n        // Make sure that all expanded values are calculated\n        // We take every node with no downlinks (bottom of the graph) and do a recursive recalculation (upwards).\n        // Not super efficient, but simple to implement\n        for (const node of this.nodes.values()) {\n            if (node.downlinks.length == 0) {\n                node.recalculate_expanded_value(true);\n            }\n        }\n    }\n    debug_print_representation() {\n        let text = \"Dependency graph nodes (DEBUG view):\";\n        for (const node of this.nodes.values()) {\n            const dependencies = node.downlinks.map(n => n.placeholder.name).join(\", \");\n            if (dependencies.length == 0) {\n                text += `\\n${node.placeholder.name} (${node.placeholder.expanded_value}) has no dependencies`;\n            }\n            else {\n                text += `\\n${node.placeholder.name} (${node.placeholder.expanded_value}) depends on ${dependencies}`;\n            }\n        }\n        logger.debug(text);\n    }\n    unmark_everything() {\n        for (const node of this.nodes.values()) {\n            node.marked = false;\n        }\n    }\n    get_node(placeholder) {\n        const node = this.nodes.get(placeholder.name);\n        if (node == undefined) {\n            throw new Error(`Placeholder ${placeholder.name} is not part of the dependency graph`);\n        }\n        else {\n            return node;\n        }\n    }\n    on_placeholder_value_change(placeholder) {\n        const node = this.get_node(placeholder);\n        this.update_placeholder_downlinks(placeholder);\n        if (this.has_loop()) {\n            // Emergency measure: ignore any placeholders in this value. This should fix the loop\n            placeholder.expanded_value = placeholder.current_value;\n            node.downlinks = [];\n            // Also raise an exception to inform the user\n            throw new Error(`Placeholder ${placeholder.name} was part of a loop and has temporarily been made non-recursive`);\n        }\n        else {\n            node.recalculate_expanded_value(true);\n        }\n    }\n    get_all_marked() {\n        const marked = [];\n        for (const node of this.nodes.values()) {\n            if (node.marked) {\n                marked.push(node.placeholder);\n            }\n        }\n        return marked;\n    }\n    get_all_upstream(placeholder) {\n        this.unmark_everything();\n        const node = this.get_node(placeholder);\n        node.recursive_mark_upstream();\n        return this.get_all_marked();\n    }\n    update_placeholder_downlinks(placeholder) {\n        if (placeholder.allow_recursive == false) {\n            // By definition, non-recursive placeholders can not rely on other placeholders\n            return;\n        }\n        // Step 1: remove all old downlinks\n        const node = this.get_node(placeholder);\n        for (const old_downlink of node.downlinks) {\n            old_downlink.remove_uplink(node);\n        }\n        node.downlinks = [];\n        // Step 2: parse placeholder's value (again)\n        for (const other_node of this.nodes.values()) {\n            // No placeholder should directly be able to contain itself -> ignoring this case.\n            // This should lead to the placeholder's name appearing in it's text, which was probably intended\n            if (other_node != node) {\n                if (string_contains_placeholder(placeholder.current_value, other_node.placeholder)) {\n                    // This placeholders value contains a reference to the other node's placeholder\n                    //  -> This node depends on the other node\n                    node.downlinks.push(other_node);\n                    other_node.uplinks.push(node);\n                }\n            }\n        }\n    }\n    get_all_used_placeholders() {\n        // Also includes all placeholders used by the placeholders that were included\n        this.unmark_everything();\n        // Mark all used placeholders and their downstream nodes\n        for (const node of this.nodes.values()) {\n            if (node.placeholder.count_on_page > 0) {\n                node.recursive_mark_downstream();\n            }\n        }\n        return this.get_all_marked();\n    }\n    has_loop() {\n        // General algorithm: https://www.geeksforgeeks.org/detect-cycle-in-a-graph/\n        this.unmark_everything();\n        for (const node of this.nodes.values()) {\n            // Make sure that we check every single node (we likely have multiple graphs that are not connected)\n            if (!node.marked) {\n                if (this._has_loop([], node)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    _has_loop(back_stack, current_node) {\n        const new_back_stack = [...back_stack, current_node];\n        const index = back_stack.indexOf(current_node);\n        if (index != -1) {\n            let message = \"Dependency cycle in placeholders detected:\";\n            for (let i = index; i < new_back_stack.length; i++) {\n                const placeholder = new_back_stack[i].placeholder;\n                message += `\\n$ -> ${placeholder.name}: ${placeholder.current_value}`;\n            }\n            console.warn(message);\n            return true;\n        }\n        else if (!current_node.marked) {\n            // No cycle found yet, scan all children that are not yet marked\n            current_node.marked = true;\n            for (const child of current_node.downlinks) {\n                if (this._has_loop(new_back_stack, child)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        else {\n            // Already checked, so no need to start recursive scans\n            return false;\n        }\n    }\n}\nconst string_contains_placeholder = (string_to_test, placeholder_to_find) => {\n    return placeholder_to_find.regex_dynamic.test(string_to_test) ||\n        placeholder_to_find.regex_html.test(string_to_test) ||\n        placeholder_to_find.regex_normal.test(string_to_test) ||\n        placeholder_to_find.regex_static.test(string_to_test);\n};\nclass GraphNode {\n    constructor(placeholder) {\n        // These other nodes depend on this node\n        this.uplinks = [];\n        // This are the nodes this node depends on\n        this.downlinks = [];\n        // State used during operations to see if this node was already visited/processed\n        this.marked = false;\n        this.placeholder = placeholder;\n    }\n    remove_uplink(node) {\n        this.uplinks = this.uplinks.filter(x => x != node);\n    }\n    recalculate_expanded_value(recursive) {\n        let expanded_value = this.placeholder.current_value;\n        for (const downlink_node of this.downlinks) {\n            expanded_value = replace_placeholder_in_string(expanded_value, downlink_node.placeholder);\n        }\n        this.placeholder.expanded_value = expanded_value;\n        if (recursive) {\n            // Recalculate all uplink nodes in recursive too\n            for (const uplink_node of this.uplinks) {\n                uplink_node.recalculate_expanded_value(recursive);\n            }\n        }\n    }\n    recursive_mark_upstream() {\n        this.marked = true;\n        for (const node of this.uplinks) {\n            node.recursive_mark_upstream();\n        }\n    }\n    recursive_mark_downstream() {\n        this.marked = true;\n        for (const node of this.downlinks) {\n            node.recursive_mark_downstream();\n        }\n    }\n}\n","import { load_checkbox_state, load_dropdown_state, load_textbox_state } from \"./state_manager\";\nimport { parse_validator } from \"./validator\";\nimport { DependencyGraph } from \"./dependency_graph\";\n// This should be a more type safe reimplementation of 10_parse_data.js.\n// It has some breaking changes, since I try to improve how the javascript code works\nexport const assert_field_type = (name, expected_type_str, parent_object) => {\n    const value = parent_object[name];\n    const actual_type_str = typeof (value);\n    if (actual_type_str != expected_type_str) {\n        throw new Error(`Type mismatch: ${name} should be ${expected_type_str}, but is ${actual_type_str}.\\nProblematic object: ${JSON.stringify(parent_object)}`);\n    }\n    else {\n        return value;\n    }\n};\n// These functions are here to make sure, that I the type checker can properly work (since they have a specific return type)\nexport const get_string_field = (name, parent_object) => {\n    return assert_field_type(name, \"string\", parent_object);\n};\nexport const get_boolean_field = (name, parent_object) => {\n    return assert_field_type(name, \"boolean\", parent_object);\n};\nconst get_number_field = (name, parent_object) => {\n    return assert_field_type(name, \"number\", parent_object);\n};\nexport const get_array_field = (name, element_type, parent_object) => {\n    const array = parent_object[name];\n    if (Array.isArray(array)) {\n        for (const [index, entry] of array.entries()) {\n            const actual_type_str = typeof (entry);\n            if (actual_type_str != element_type) {\n                const msg = `Type mismatch: ${name}'s ${index + 1}th element should be ${element_type}, but is ${actual_type_str}.\\nProblematic object: ${JSON.stringify(parent_object)}`;\n                throw new Error(msg);\n            }\n        }\n        return array;\n    }\n    else {\n        throw new Error(`Type mismatch: ${name} should be an array, but is not.\\nProblematic object: ${JSON.stringify(parent_object)}`);\n    }\n};\nexport var InputType;\n(function (InputType) {\n    InputType[\"Textbox\"] = \"TEXTBOX\";\n    InputType[\"Checkbox\"] = \"CHECKBOX\";\n    InputType[\"Dropdown\"] = \"DROPDOWN\";\n})(InputType || (InputType = {}));\nexport const parse_config = (data) => {\n    const placeholder_map = new Map();\n    const textboxes = new Map();\n    const checkboxes = new Map();\n    const dropdowns = new Map();\n    const validator_map = new Map();\n    const validator_data_list = get_array_field(\"validators\", \"object\", data);\n    for (const validator_data of validator_data_list) {\n        const validator = parse_validator(validator_data);\n        if (validator_map.has(validator.id)) {\n            throw new Error(`Multiple validators with id '${validator.id}'`);\n        }\n        else {\n            validator_map.set(validator.id, validator);\n        }\n    }\n    const settings_data = assert_field_type(\"settings\", \"object\", data);\n    const settings = parse_settings(settings_data);\n    const placeholder_data = get_array_field(\"placeholder_list\", \"object\", data);\n    for (let i = 0; i < placeholder_data.length; i++) {\n        const placeholder = parse_any_placeholder(placeholder_data[i], validator_map, settings, i);\n        // Add the placeholder to the correct lists\n        placeholder_map.set(placeholder.name, placeholder);\n        if (placeholder.type == InputType.Textbox) {\n            textboxes.set(placeholder.name, placeholder);\n        }\n        else if (placeholder.type == InputType.Checkbox) {\n            checkboxes.set(placeholder.name, placeholder);\n        }\n        else if (placeholder.type == InputType.Dropdown) {\n            dropdowns.set(placeholder.name, placeholder);\n        }\n        else {\n            console.warn(\"Unknown placeholder type:\", placeholder.type);\n        }\n    }\n    const graph = new DependencyGraph(placeholder_map);\n    return {\n        \"placeholders\": placeholder_map,\n        \"textboxes\": textboxes,\n        \"checkboxes\": checkboxes,\n        \"dropdowns\": dropdowns,\n        \"settings\": settings,\n        \"dependency_graph\": graph,\n        \"input_tables\": [],\n    };\n};\nconst parse_settings = (data) => {\n    return {\n        \"debug\": get_boolean_field(\"debug\", data),\n        \"delay_millis\": get_number_field(\"delay_millis\", data),\n        // @TODO: If I let users specify prefixes, I will need to make sure, that they do not contain regex characters or escape them\n        // How normal placeholders are marked\n        \"normal_prefix\": \"x\",\n        \"normal_suffix\": \"x\",\n        // How placeholders using the innerHTML method are marked\n        \"html_prefix\": \"i\",\n        \"html_suffix\": \"i\",\n        // How placeholders using the direct/static replacement methodare marked\n        \"static_prefix\": \"s\",\n        \"static_suffix\": \"s\",\n        // How placeholders using the dynamic replacement methodare marked\n        \"dynamic_prefix\": \"d\",\n        \"dynamic_suffix\": \"d\",\n    };\n};\nconst parse_any_placeholder = (data, validator_map, settings, index) => {\n    const type = get_string_field(\"type\", data);\n    // Parse fields that are shared between all placeholders\n    const name = get_string_field(\"name\", data);\n    let parsed = {\n        \"name\": name,\n        \"order_index\": index,\n        // The regexes for the different replace methods. Stored here so that I only need to compile them once\n        \"regex_dynamic\": RegExp(settings.dynamic_prefix + name + settings.dynamic_suffix, \"g\"),\n        \"regex_html\": RegExp(settings.html_prefix + name + settings.html_suffix, \"g\"),\n        \"regex_normal\": RegExp(settings.normal_prefix + name + settings.normal_suffix, \"g\"),\n        \"regex_static\": RegExp(settings.static_prefix + name + settings.static_suffix, \"g\"),\n        // \n        \"description\": get_string_field(\"description\", data),\n        \"read_only\": get_boolean_field(\"read_only\", data),\n        \"allow_inner_html\": get_boolean_field(\"allow_inner_html\", data),\n        \"allow_recursive\": false,\n        \"current_value\": \"UNINITIALIZED\",\n        \"expanded_value\": \"UNINITIALIZED\",\n        \"count_on_page\": 0,\n        \"reload_page_on_change\": false,\n        \"output_elements\": [], // Will be set, when the page is searched\n    };\n    // Parse the type specific attributes\n    if (type === \"textbox\") {\n        const placeholder = finish_parse_textbox(parsed, data, validator_map);\n        load_textbox_state(placeholder);\n        return placeholder;\n    }\n    else if (type == \"checkbox\") {\n        const placeholder = finish_parse_checkbox(parsed, data);\n        load_checkbox_state(placeholder);\n        return placeholder;\n    }\n    else if (type == \"dropdown\") {\n        const placeholder = finish_parse_dropdown(parsed, data);\n        load_dropdown_state(placeholder);\n        return placeholder;\n    }\n    else {\n        throw new Error(`Unsupported placeholder type '${type}'`);\n    }\n};\nconst finish_parse_textbox = (parsed, data, validator_map) => {\n    let default_function, default_value;\n    if (data[\"default_value\"] != undefined) {\n        default_value = get_string_field(\"default_value\", data);\n    }\n    else {\n        const default_js_code = get_string_field(\"default_function\", data);\n        default_function = () => {\n            // Wrap the function, so that we can ensure that errors are properly handled\n            try {\n                const compiled_function = new Function(default_js_code);\n                const result = compiled_function();\n                if (typeof (result) != \"string\") {\n                    throw new Error(`Custom function '${default_js_code}' should return a string, but it returned a ${typeof (result)}: ${result}`);\n                }\n                else {\n                    return result;\n                }\n            }\n            catch (error) {\n                throw new Error(`Failed to evaluate default_function '${default_js_code}' of placeholder ${parsed.name}: ${error}`);\n            }\n        };\n    }\n    const validator_names = get_array_field(\"validators\", \"string\", data);\n    const validator_list = [];\n    for (const name of validator_names) {\n        const validator = validator_map.get(name);\n        if (validator) {\n            validator_list.push(validator);\n        }\n        else {\n            const known_validators = Array.from(validator_map.keys()).join(\", \");\n            throw new Error(`No validator with id '${name}' was found. Known validators are ${known_validators}`);\n        }\n    }\n    return Object.assign(Object.assign({}, parsed), { \"allow_recursive\": get_boolean_field(\"allow_recursive\", data), \"default_function\": default_function, \"default_value\": default_value, \"input_elements\": [], \"type\": InputType.Textbox, \"validators\": validator_list });\n};\nconst finish_parse_checkbox = (parsed, data) => {\n    return Object.assign(Object.assign({}, parsed), { \"allow_recursive\": true, \"checked_by_default\": get_boolean_field(\"checked_by_default\", data), \"current_is_checked\": false, \"input_elements\": [], \"value_checked\": get_string_field(\"value_checked\", data), \"value_unchecked\": get_string_field(\"value_unchecked\", data), \"type\": InputType.Checkbox });\n};\nconst finish_parse_dropdown = (parsed, data) => {\n    const raw_options = get_array_field(\"options\", \"object\", data);\n    const options = [];\n    for (const option of raw_options) {\n        options.push({\n            display_name: get_string_field(\"display_name\", option),\n            value: get_string_field(\"value\", option),\n        });\n    }\n    const default_index = get_number_field(\"default_index\", data);\n    if (default_index < 0) {\n        throw new Error(`Invalid value: \"default_index\" should not be negative, but is ${default_index}.\\nProblematic object: ${JSON.stringify(data)}`);\n    }\n    else if (default_index >= options.length) {\n        throw new Error(`Invalid value: \"default_index\" should be smaller than the number of options (${options.length}), but is ${default_index}.\\nProblematic object: ${JSON.stringify(data)}`);\n    }\n    return Object.assign(Object.assign({}, parsed), { \"allow_recursive\": true, \"current_index\": 0, \"default_index\": default_index, \"input_elements\": [], \"options\": options, \"type\": InputType.Dropdown });\n};\n","import { logger } from \"./debug\";\nimport { prepare_input_field } from \"./inputs\";\nimport { create_dynamic_placeholder_element } from \"./replacer\";\nconst TABLE_CELL_HEADINGS = new Map();\nTABLE_CELL_HEADINGS.set(\"name\", \"Name\");\nTABLE_CELL_HEADINGS.set(\"description\", \"Description\");\nTABLE_CELL_HEADINGS.set(\"value\", \"Value\");\nTABLE_CELL_HEADINGS.set(\"input\", \"Input element\");\nTABLE_CELL_HEADINGS.set(\"description-or-name\", \"Description / name\");\n// Helper functions to simplify the following code\nconst appendTextNode = (element, text) => {\n    element.appendChild(document.createTextNode(text));\n};\nconst createChildElement = (parent, tag_name) => {\n    const child = document.createElement(tag_name);\n    parent.appendChild(child);\n    return child;\n};\nconst generate_automatic_placeholder_table = (element, columns, config, placeholders_to_show) => {\n    placeholders_to_show = sort_and_remove_duplicate_placeholders(placeholders_to_show);\n    // Remove the current contents. This enables the plugin to generate fallback contents in case the JavaScript code does not work\n    element.innerHTML = \"\";\n    if (placeholders_to_show.length == 0) {\n        // Do not create an empty table. Instead show a warning on the page\n        const div = createChildElement(element, \"div\");\n        div.classList.add(\"info-message\");\n        if (placeholders_to_show.length == 0) {\n            appendTextNode(div, \"No placeholders to be shown\");\n        }\n        return;\n    }\n    logger.info(\"Creating automatic input table at\", element, \"with columns\", columns);\n    // element.innerHTML = \"\"; // remove all children\n    const table = createChildElement(element, \"table\");\n    const table_head = createChildElement(table, \"thead\");\n    const table_head_row = createChildElement(table_head, \"tr\");\n    const table_body = createChildElement(table, \"tbody\");\n    for (const column of columns) {\n        const table_cell = createChildElement(table_head_row, \"th\");\n        const heading = TABLE_CELL_HEADINGS.get(column);\n        if (heading) {\n            appendTextNode(table_cell, heading);\n        }\n        else {\n            appendTextNode(table_cell, column);\n            console.error(`Unknown column name: ${column}`);\n        }\n    }\n    const rows = [];\n    for (const placeholder of placeholders_to_show) {\n        if (placeholder.read_only) {\n            logger.debug(`auto_table: Skipping ${placeholder.name} because it is read-only`);\n            continue;\n        }\n        const row = createChildElement(table_body, \"tr\");\n        populate_auto_table_row(row, placeholder, columns, config);\n        rows.push({\n            \"element\": row,\n            \"placeholder\": placeholder,\n        });\n    }\n    config.input_tables.push({\n        \"columns\": columns,\n        \"table_element\": table,\n        \"rows\": rows,\n    });\n};\nconst sort_and_remove_duplicate_placeholders = (placeholder_list) => {\n    return [...new Set(placeholder_list)].sort((a, b) => a.order_index - b.order_index);\n};\nconst populate_auto_table_row = (row, placeholder, columns, config) => {\n    for (const column of columns) {\n        const cell = createChildElement(row, \"td\");\n        if (column == \"name\") {\n            appendTextNode(cell, placeholder.name);\n        }\n        else if (column == \"description\") {\n            appendTextNode(cell, placeholder.description);\n        }\n        else if (column == \"value\") {\n            const dynamic_placeholer = create_dynamic_placeholder_element(placeholder);\n            cell.appendChild(dynamic_placeholer);\n            placeholder.output_elements.push(dynamic_placeholer);\n        }\n        else if (column == \"input\") {\n            const input = createChildElement(cell, \"input\");\n            prepare_input_field(config, placeholder, input);\n        }\n        else if (column == \"description-or-name\") {\n            const text = placeholder.description || placeholder.name;\n            appendTextNode(cell, text);\n        }\n        else {\n            console.error(`Unknown column name: ${column}`);\n        }\n    }\n};\nconst update_auto_table = (config, table, new_placeholder_list) => {\n    // Sort them the same way they are sorted in the table -> lists are easy to compare\n    new_placeholder_list = sort_and_remove_duplicate_placeholders(new_placeholder_list);\n    // Step 1: remove rows that are no longer to be shown\n    const rows_to_keep = [];\n    for (const row of table.rows) {\n        if (new_placeholder_list.includes(row.placeholder)) {\n            rows_to_keep.push(row);\n        }\n        else {\n            logger.debug(`Removed table row for ${row.placeholder.name}:`, row.element);\n            row.element.remove();\n        }\n    }\n    // Step 2: add rows that do not yet exist\n    const final_rows = [];\n    const reversed_current = [...rows_to_keep].reverse();\n    const reversed_new = [...new_placeholder_list].reverse();\n    let next_new;\n    while (next_new = reversed_new.pop()) {\n        // const next_new = reversed_new.pop();\n        const next_current = reversed_current.slice(-1)[0];\n        if (next_current && next_current.placeholder === next_new) {\n            // The row is already in the table\n            reversed_current.pop(); // remove from queue to keep in sync with other queue\n            final_rows.push(next_current);\n        }\n        else {\n            const element = document.createElement(\"tr\");\n            // insert at the correct position in the dom\n            if (final_rows.length == 0) {\n                // adds it before the first child or if it does not exist at the end (which would also be the first element :D)\n                table.table_element.insertBefore(element, table.table_element.firstChild);\n            }\n            else {\n                // insert it after the last row that was processed\n                const last_node = final_rows[final_rows.length - 1].element;\n                last_node.insertAdjacentElement(\"afterend\", element);\n            }\n            populate_auto_table_row(element, next_new, table.columns, config);\n            final_rows.push({\n                \"element\": element,\n                \"placeholder\": next_new,\n            });\n            logger.debug(`Added table row for ${next_new.name}:`, element);\n        }\n    }\n    // Store the updated row information in the original table object\n    table.rows = final_rows;\n};\nexport const update_all_auto_tables = (config) => {\n    logger.debug(`Updating ${config.input_tables.length} automatic input tables`);\n    if (config.input_tables.length > 0) {\n        const new_placeholder_list = config.dependency_graph.get_all_used_placeholders();\n        for (const table of config.input_tables) {\n            update_auto_table(config, table, new_placeholder_list);\n        }\n    }\n};\nexport const initialize_auto_tables = (config) => {\n    const element_list = document.querySelectorAll(\"div.auto-input-table\");\n    if (element_list.length > 0) {\n        const used_placeholders = config.dependency_graph.get_all_used_placeholders().filter(x => !x.read_only);\n        for (let element of element_list) {\n            const columns_str = element.getAttribute(\"data-columns\") || \"name,input\";\n            const columns = columns_str.includes(\",\") ? columns_str.split(\",\") : [columns_str];\n            generate_automatic_placeholder_table(element, columns, config, used_placeholders);\n        }\n    }\n};\n","import { update_all_auto_tables } from \"./auto_tables\";\nimport { logger, reload_page } from \"./debug\";\nimport { InputType } from \"./parse_settings\";\nimport { replace_dynamic_placeholder_values } from \"./replacer\";\nimport { store_checkbox_state, store_dropdown_state, store_textbox_state } from \"./state_manager\";\nimport { validate_textbox_input_field } from \"./validator\";\nexport const initialize_all_input_fields = (config) => {\n    const input_list = document.querySelectorAll(\"input[data-input-for]\");\n    for (let input_element of input_list) {\n        const placeholder_name = input_element.getAttribute(\"data-input-for\");\n        if (placeholder_name == null) {\n            throw new Error(\"How can this be, the selector forces the 'data-input-for' attribute to exist\");\n        }\n        const placeholder = config.placeholders.get(placeholder_name);\n        if (placeholder) {\n            prepare_input_field(config, placeholder, input_element);\n        }\n        else {\n            console.warn(`Unknown placeholder referenced in input element: '${placeholder_name}'`);\n            input_element.classList.add(\"input-for-variable\");\n            input_element.value = `ERROR_UNDEFINED_PLACEHOLDER: ${placeholder_name}`;\n        }\n    }\n};\nexport const prepare_input_field = (config, placeholder, input_element) => {\n    input_element.classList.add(\"input-for-variable\");\n    if (placeholder.type == InputType.Checkbox) {\n        initialize_input_checkbox(config, placeholder, input_element);\n    }\n    else if (placeholder.type == InputType.Dropdown) {\n        initialize_input_dropdown(config, placeholder, input_element);\n    }\n    else if (placeholder.type == InputType.Textbox) {\n        initialize_input_textbox(config, placeholder, input_element);\n    }\n    else {\n        console.error(`Placeholder ${placeholder.name} has unknown type '${placeholder.type}'`);\n    }\n};\nconst initialize_input_checkbox = (config, placeholder, input_element) => {\n    input_element.type = \"checkbox\";\n    input_element.checked = placeholder.current_is_checked;\n    if (placeholder.read_only) {\n        // disable the checkbox\n        input_element.disabled = true;\n    }\n    else {\n        // Listen for state changes\n        input_element.addEventListener(\"change\", () => {\n            logger.debug(\"Checkbox change\", placeholder.name, \"- new value:\", input_element.checked);\n            store_checkbox_state(placeholder, input_element.checked);\n            placeholder.current_value = input_element.checked ? placeholder.value_checked : placeholder.value_unchecked;\n            on_placeholder_change(config, placeholder);\n        });\n    }\n    // Store this input element\n    placeholder.input_elements.push(input_element);\n};\nconst initialize_input_dropdown = (config, placeholder, input_element) => {\n    const new_node = document.createElement(\"select\");\n    new_node.classList.add(\"placeholder-dropdown\");\n    for (const option of placeholder.options) {\n        const option_element = document.createElement(\"option\");\n        option_element.text = option.display_name; // @TODO: allow placeholders in here\n        new_node.appendChild(option_element);\n    }\n    // Replace input element entirely with the dropdown menu\n    if (input_element.parentNode) {\n        input_element.parentNode.replaceChild(new_node, input_element);\n    }\n    else {\n        // How would we find it in the DOM if it has no parent?\n        console.error(`Input element`, input_element, `for placeholder ${placeholder.name} has no parent!`);\n    }\n    // Select the stored option\n    new_node.selectedIndex = placeholder.current_index;\n    if (placeholder.read_only) {\n        // disable the dropdown\n        new_node.disabled = true;\n    }\n    else {\n        // Add an event listener\n        new_node.addEventListener(\"change\", () => {\n            logger.debug(\"Dropdown change\", placeholder.name, \"- new index:\", new_node.selectedIndex);\n            store_dropdown_state(placeholder, new_node.selectedIndex);\n            placeholder.current_index = new_node.selectedIndex;\n            placeholder.current_value = placeholder.options[new_node.selectedIndex].value;\n            on_placeholder_change(config, placeholder);\n        });\n    }\n    // Store this input element\n    placeholder.input_elements.push(new_node);\n};\nconst initialize_input_textbox = (config, placeholder, input_element) => {\n    // Restore the stored state\n    input_element.value = placeholder.current_value;\n    if (placeholder.read_only) {\n        // disable the checkbox\n        input_element.disabled = true;\n        input_element.style.cursor = \"not-allowed\";\n    }\n    else {\n        if (placeholder.default_value != undefined) {\n            input_element.placeholder = `Default: ${placeholder.default_value}`;\n        }\n        else {\n            input_element.placeholder = \"Dynamic default value\";\n        }\n        const on_keypress = (event) => {\n            if (event.key === \"Enter\") {\n                logger.debug(\"Textbox change confirmed with Enter key for \", placeholder.name, \"- new value:\", input_element.value);\n                if (validate_textbox_input_field(placeholder, input_element)) {\n                    store_textbox_state(placeholder, input_element.value);\n                    placeholder.current_value = input_element.value;\n                    on_placeholder_change(config, placeholder);\n                }\n            }\n            else if (event.key === \"Escape\") {\n                // @TODO: why does this not get triggered? Is it intercepted by something else?\n                logger.debug(\"Resetting input field for \", placeholder.name, \" to current placeholder value\");\n                input_element.value = placeholder.current_value;\n            }\n        };\n        if (placeholder.validators.length == 0) {\n            // No validators -> no need to handle exception when validation fails\n            input_element.addEventListener(\"keypress\", on_keypress);\n        }\n        else {\n            // Check if initial value is valid\n            validate_textbox_input_field(placeholder, input_element);\n            // Listen for state changes\n            input_element.addEventListener(\"input\", () => {\n                // The text was probably modified, so we need to update the validator\n                validate_textbox_input_field(placeholder, input_element);\n            });\n            input_element.addEventListener(\"keypress\", on_keypress);\n        }\n    }\n    // Store this input element\n    placeholder.input_elements.push(input_element);\n};\nconst on_placeholder_change = (config, placeholder) => {\n    const affected_placeholders = config.dependency_graph.get_all_upstream(placeholder);\n    let require_reload = false;\n    for (const ph of affected_placeholders) {\n        require_reload = require_reload || ph.reload_page_on_change;\n    }\n    logger.debug(`Change of ${placeholder.name} requires updates for placeholders:\\n${affected_placeholders.map(p => ` - ${p.name}\\n`).join(\"\")}\\nRequires reload: ${require_reload}`);\n    if (require_reload) {\n        reload_page(); // for now we just use the full reload\n    }\n    else {\n        config.dependency_graph.on_placeholder_value_change(placeholder);\n        // update auto-tables, since downstream may be changed\n        update_all_auto_tables(config);\n        // Update all input elements for the modified placeholder\n        if (placeholder.type == InputType.Checkbox) {\n            const ph = placeholder;\n            for (const input_element of ph.input_elements) {\n                input_element.checked = ph.current_is_checked;\n            }\n        }\n        else if (placeholder.type == InputType.Dropdown) {\n            const ph = placeholder;\n            for (const input_element of ph.input_elements) {\n                input_element.selectedIndex = ph.current_index;\n            }\n        }\n        else if (placeholder.type == InputType.Textbox) {\n            const ph = placeholder;\n            for (const input_element of ph.input_elements) {\n                input_element.value = ph.current_value;\n                validate_textbox_input_field(ph, input_element);\n            }\n        }\n        else {\n            console.warn(`Placeholder ${placeholder.name} has unexpected type '${placeholder.type}'`);\n        }\n        // @TODO Not needed as long as the dropdown display name is static\n        // // Update input elements\n        // for (const ph of affected_placeholders) {\n        //     // Only dropdown's input elements can depend on other placeholders (the label)\n        //     if (ph.type == InputType.Dropdown) {\n        //         for (const input of (ph as DropdownPlaceholder).input_elements) {\n        //             // code here\n        //         }\n        //     }\n        // }\n        // Update output elements\n        replace_dynamic_placeholder_values(affected_placeholders);\n    }\n};\n","import { parse_config } from \"./parse_settings\";\nimport { init_logging, logger } from \"./debug\";\nimport { replace_placeholders_in_subtree } from \"./replacer\";\nimport { initialize_all_input_fields } from \"./inputs\";\nimport { export_api_functions } from \"./api\";\nimport { initialize_auto_tables } from \"./auto_tables\";\nexport const main = () => {\n    const config = parse_config(window.PlaceholderPluginConfigJson);\n    init_logging(config.settings.debug);\n    logger.info(\"PluginConfig\", config);\n    export_api_functions(config);\n    const delay_millis = config.settings.delay_millis;\n    // Then do the placeholder replacing at the user-specified time\n    if (delay_millis < 0) {\n        // For values smaller than 0, immediately do the replacements\n        do_plugin_stuff(config);\n    }\n    else if (delay_millis == 0) {\n        // Replace placeholders as soon as the page finished loading\n        window.addEventListener(\"load\", () => do_plugin_stuff(config));\n    }\n    else {\n        // Wait the amount of millis specified by the user\n        window.addEventListener(\"load\", () => {\n            setTimeout(() => do_plugin_stuff(config), delay_millis);\n        });\n    }\n};\nconst do_plugin_stuff = (config) => {\n    replace_placeholders_in_subtree(document.body, config);\n    config.dependency_graph.debug_print_representation();\n    initialize_all_input_fields(config);\n    initialize_auto_tables(config);\n};\n","import { debug_disable_reload } from \"./debug\";\nexport const export_api_functions = (config) => {\n    window.PlaceholderPlugin = {\n        \"settings\": config.settings,\n        \"placeholders\": config.placeholders,\n        \"debug_disable_reload\": debug_disable_reload,\n        \"debug_print_dependency_graph\": () => config.dependency_graph.debug_print_representation(),\n    };\n};\n","import { main } from \"./main\";\n// If the data is loaded via another script, make it work in any order\nif (window.PlaceholderPluginConfigJson) {\n    main();\n}\nelse {\n    document.addEventListener(\"PlaceholderPluginConfigJson\", main);\n}\n"],"names":["timestamp","Date","toISOString","slice","is_reload_enabled","internal_log","args","console","log","apply","arguments","internal_info","info","internal_debug","debug","noop","reload_page","window","location","reload","noop_logger","logger","debug_disable_reload","ValidatorSeverity","PlaceholderValidatity","parse_validator","data","rules","get_array_field","length","Error","JSON","stringify","id","get_string_field","map","x","parse_rule","is_valid_value","validator","value","rule","is_match_function","should_match","severity","is_valid_value_for_placeholder","placeholder","validators","validate_value","warnings","errors","push","display_name","error_message","Warning","warn","placeholder_is_good","message","v","Good","validator_id","severity_str","regex","compiled_regex","RegExp","test","match_function_body","match_function","Function","result","error","get_boolean_field","validate_textbox_input_field","input_field","result_list","has_no_error","lines","join","placeholder_is_warning","placeholder_is_error","NoValidator","validate_placeholder_value","validation_result","classList","remove","rating","add","title","update_tooltip","name","STORAGE_PREFIX","store_value","localStorage","setItem","load_value","getItem","clear_state","i","key","startsWith","removeItem","is_valid_index","index","item","options","undefined","store_textbox_state","new_value","is_validation_ok","escapeHTML","text","element","document","createElement","appendChild","createTextNode","innerHTML","create_dynamic_placeholder_element","span","dataset","textContent","expanded_value","dynamic_replace","root_element","search_regex","_a","walker","createTreeWalker","NodeFilter","SHOW_TEXT","node","global","source","current_value","nodes_to_modify","nextNode","nodeValue","match","replacement_value","replaced_str","replace","new_node","parentElement","replaceChild","do_dynamic_replace","config","count","regex_dynamic","count_on_page","do_normal_replace","regex_normal","do_static_replace","static_replace","regex_static","reload_page_on_change","do_html_replace","inner_html_replace","regex_html","replace_dynamic_placeholder_values","placeholder_list","output_elements","DependencyGraph","constructor","placeholders","this","nodes","Map","values","set","GraphNode","on_placeholder_value_change","e","confirm","downlinks","recalculate_expanded_value","debug_print_representation","dependencies","n","unmark_everything","marked","get_node","get","update_placeholder_downlinks","has_loop","get_all_marked","get_all_upstream","recursive_mark_upstream","allow_recursive","old_downlink","remove_uplink","other_node","string_contains_placeholder","uplinks","get_all_used_placeholders","recursive_mark_downstream","_has_loop","back_stack","current_node","new_back_stack","indexOf","child","string_to_test","placeholder_to_find","filter","recursive","downlink_node","uplink_node","assert_field_type","expected_type_str","parent_object","actual_type_str","get_number_field","element_type","array","Array","isArray","entry","entries","msg","InputType","parse_any_placeholder","validator_map","settings","type","parsed","dynamic_prefix","dynamic_suffix","html_prefix","html_suffix","normal_prefix","normal_suffix","static_prefix","static_suffix","finish_parse_textbox","stored_state","default_value","default_function","load_textbox_state","finish_parse_checkbox","current_is_checked","checked_by_default","value_checked","value_unchecked","load_checkbox_state","finish_parse_dropdown","current_index","default_index","stored_index","Number","load_dropdown_state","default_js_code","compiled_function","validator_names","validator_list","known_validators","from","keys","Object","assign","Textbox","Checkbox","raw_options","option","Dropdown","TABLE_CELL_HEADINGS","appendTextNode","createChildElement","parent","tag_name","generate_automatic_placeholder_table","columns","placeholders_to_show","sort_and_remove_duplicate_placeholders","div","table","table_head","table_head_row","table_body","column","table_cell","heading","rows","read_only","row","populate_auto_table_row","input_tables","Set","sort","a","b","order_index","cell","description","dynamic_placeholer","input","prepare_input_field","update_auto_table","new_placeholder_list","rows_to_keep","includes","final_rows","reversed_current","reverse","reversed_new","next_new","pop","next_current","table_element","insertBefore","firstChild","insertAdjacentElement","input_element","initialize_input_checkbox","initialize_input_dropdown","initialize_input_textbox","checked","disabled","addEventListener","new_is_checked","store_checkbox_state","on_placeholder_change","input_elements","option_element","parentNode","selectedIndex","new_index","store_dropdown_state","style","cursor","on_keypress","event","affected_placeholders","dependency_graph","require_reload","ph","p","update_all_auto_tables","main","placeholder_map","textboxes","checkboxes","dropdowns","validator_data_list","validator_data","has","parse_settings","placeholder_data","parse_config","PlaceholderPluginConfigJson","enable_debug","PlaceholderPlugin","export_api_functions","delay_millis","do_plugin_stuff","setTimeout","allow_inner_html","output_list","querySelectorAll","placeholder_name","getAttribute","find_dynamic_placeholder_wrappers","replace_placeholders_in_subtree","body","input_list","initialize_all_input_fields","element_list","used_placeholders","columns_str","split","initialize_auto_tables"],"sourceRoot":""}
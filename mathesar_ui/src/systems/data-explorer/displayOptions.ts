import type { ColumnMetadata } from '@mathesar/api/rpc/_common/columnDisplayOptions';
import type {
  AddableExploration,
  ExplorationResult,
  QueryResultColumn,
} from '@mathesar/api/rpc/explorations';

interface ColumnAnchor {
  name: string;
  index: number;
  type: {
    name: string;
    item_type?: string;
  };
}

export interface ColumnDisplayOptionsEntry {
  column: ColumnAnchor;
  displayOptions: ColumnMetadata;
}

/**
 * Keys are the stringified indexes (zero-based) of the column in the
 * exploration result set.
 */
type ColumnDisplayOptions = Record<string, ColumnDisplayOptionsEntry>;

export interface ExplorationDisplayOptions {
  columnDisplayOptions?: ColumnDisplayOptions | null;
}

export function validateDisplayOptions(
  input: AddableExploration['display_options'],
): ExplorationDisplayOptions {
  if (!input) {
    return {
      columnDisplayOptions: {},
    };
  }

  return input as ExplorationDisplayOptions;

  // You'll notice this function is not actually doing any real "validation"
  // right now. So why does it exist?
  //
  // The exploration display options represent a rare case of a non-trivial data
  // structure that the front end "owns" but that gets stored in the service
  // layer. The back end has no mechanism to validate or use exploration display
  // options. These options only ever generated by the front end and only ever
  // used by the front end.
  //
  // So if we decide to change this data structure in the future, then we might
  // need some sort of migration system so that an exploration which the user
  // generated and saved using old Mathesar code can still be used with new
  // Mathesar code.
  //
  // For these reasons, the display options types are loosely coupled with the
  // API types. We want to encapsulate all of the display options complexity
  // within this module, while still keeping the API types low-level, and
  // dependent primarily on _back-end_ code.
  //
  // There may come a day when we need more sophisticated code to handle
  // breaking changes to display options data structures.
  //
  // So for now, this function exists to serve as a clear and singular barrier
  // between the un-typed display options at the API layer and the
  // strongly-typed display options in the front end.
}

export function makeColumnAnchor(
  resultColumn: QueryResultColumn,
  index: number,
): ColumnAnchor {
  return {
    name: resultColumn.alias,
    index,
    type: {
      name: resultColumn.type,
      item_type: resultColumn.type_options?.item_type ?? undefined,
    },
  };
}

export function* getCustomColumnWidths(opts: ExplorationDisplayOptions) {
  const columnOptions = opts.columnDisplayOptions ?? {};
  for (const { column, displayOptions } of Object.values(columnOptions)) {
    const width = displayOptions.display_width ?? undefined;
    if (!width) continue;
    yield [column.name, width] as [string, number];
  }
}
